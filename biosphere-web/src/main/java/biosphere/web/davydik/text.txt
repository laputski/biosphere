ЛБ2:
1.Для начала ознакомились с синтаксисом языка Java и стандартными функциями.Узнали, что для ввода данных используется
 класс Scanner из библиотеки пакетов Java. Этот класс надо импортировать в той программе, где он будет использоваться.
 Это делается до начала открытого класса в коде программы. В классе есть методы для чтения очередного символа заданного
 типа со стандартного потока ввода, а также для проверки существования такого символа. Для работы с потоком ввода
 необходимо создать объект класса Scanner, при создании указав, с каким потоком ввода он будет связан.
2. Создаю класс GrayCodeTester , для начала прописал в нем функцию вычисления факториал,
чтобы почувствовать как работать в языке java, в дальнейшем мы будем делать проверку всей
нашей выполненной работы непосредственно в этом классе.
3.Приступил к реализации кода грея , заранее изучив как это делается и создав класс Gray
Code, в котором реализовал 2 метода :
a)encode - переводит десятичное число в код Грея.
b)decode - переводит число из кода Грея в десятичное.
4.Создал интерфейс IChromosomeCode и реализовал в нем методы encode и decode
5.Создал класс ChromosomeCode , который наследует интерфейс, созданный пункутом ранее ,
при помоще функции implements
6.По заданию необходимо , чтобы класс ChromosomeCode использовал в качестве реализации
класс GrayCode, для этого:
а)создаем объект класса GrayCode
б)для того, чтобы описать методы интерфейса на основе методов класса GrayCode необходимо
  использовать перед описанием метода команду @Override.Аннотация @Override информирует компилятор о
  том, что метод перегружает метод в суперклассе.
в)создаю класс GrayCode_inner , который наследует класс GrayCode, это делается при помощи
  команды extends. Затем создаю public объект класса GrayCode_inner .
г)Далее создаем статический класс GrayCode_nested ,который также наследует класс GrayCode
  , т.к он статический, то мы сможем обращаться к статическому методу или полю используя имя класса.
  Этот класс логически связан с классом-владельцем, но может быть использован отдельно
  от него.
7.Для проверки того, что созданные нами методы интерфейса работают, сделаем проверку в
главном классе GrayCodeTester-a, т.е создаем в main такие же методы и вызываем их.
 а) для начала создадим в GrayCodeTester методы encode и decode
 б) для проверки public метода создаем объект класса ChromosomeCode и обращаемся к нужному нам
 методу класса GrayCode
 в)для проверки внутреннего/вложенного метода static,
 для этого мы заранее в классе ChromosomeCode создали объект класса GrayCode_inner, создаем объект класса ChromosomeCode,
 и теперь  созданным объектом класса ChromosomeCode обращаемся к внутреннему объекту класса ChromosomeCode, а затем
  к нужному нам методу класса GrayCode
 г)Метод nested. Для этого создаем объект класса ChromosomeCode.GrayCode_nested(GrayCode_nested создан заранее в ChromosomeCode)
 и затем уже обращаемся к нужному нам метлду класса GrayCode.
 д) для проверки анонимного метода просто создаем объект класса ChromosomeCode и обращаемся к нужному
 методу класса GrayCode
 8.Для внутреннего, вложенного и анонимного классов завели классы TestInnerChromosomeCode, TestNestedChromosomeCode и
   TestAnonymousChromosomeCode соответственно.
 8. Inner-класы имеют доступ ко всем полям класса в который вложены, что бывает очень удобно. например Вам необходимо создать класс
   наследующий от двух родителей, что как известно в Java невозможно, но если outer-класс наследует от одного родителя, а inner от
   другого родителя, причем inner имеет доступ к полям outer-а, то inner-у доступно то что унаследовал он сам + то что унаследовал
   outer.Анонимный класс удобно использовать, когда нужно одноразово переопределить методы или создать собственные методы объекта.
   Вложенные классы выгодно использовать, Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, можно
   сделать внутренний класс статическим (static).Вложенные классы позволяют группировать классы, логически принадлежащие друг другу,
   и управлять доступом к ним.
 9 == - сравнение ссылок
   obj1,obj2 - объекты одного класса
   obj1.equals(obj2) - сравнение значений.
   если 2-й объект ссылается на 1-й и значения у них одинаковые ,то тогда true в обоих случаях